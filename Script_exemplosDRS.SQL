-- COMANDOS SQL - DIVISÃO: DQL / DRS
-- DQL (Data Query Language) -> LINGUAGEM DE CONSULTA DE DADOS
-- DRS (Data Retrieve Language ) -> LINGUAGEM DE RECUPERAÇÃO DE DADOS 
-- ALGUNS AUTORES TRATAM COMO DML - Data Manipulation Language);
-- COMANDO: SELECT -> COMANDO PARA CONSULTA/RECUPERAÇÃO DE DADOS
-- NESTE MATERIAL IREMOS TRATAR DE CONSULTA SIMPLES (CONSULTA A APENAS UMA TABELA)


--CONSULTANDO TODAS AS LINHAS E COLUNAS DA TABELA FUNCIONARIO
SELECT * FROM T_SIP_FUNCIONARIO;
/*não utilizar assim no java!Sempre colocar filtros,por exemplo:ao inves de mostrar toda a tabela
--mostrar apenas as informações que forem úteis*/
SELECT CD_DEPTO,NR_MATRICULA,NM_FUNCIONARIO FROM T_SIP_FUNCIONARIO WHERE CD_DEPTO = 3;
/*Apresenta o codigo do departamento,numero da matricula e nome do funcionario da tabela t_sip_funcionario onde o cd_depto for 3*/
--É bom usar uma chave primaria na parte do where

-- ORDENANDO COLUNAS QUE POSSUEM ALIAS




SELECT DISTINCT CD_DEPTO FROM T_SIP_FUNCIONARIO;
--o distinct tras quantos departamentos tem na tabela funcionario,porém sem repetir,tipo se 3 pessoas trabalham no departamento 57,ao inves
--de mostrar (57,57,57) ele mostrará apenas uma vez
SELECT UNIQUE CD_PROJETO FROM T_SIP_IMPLANTACAO;
/*Posso colocar tanto disctinct quanto unique--ambos irçao reallizar o mesmo comando */


SELECT DISTINCT NR_MATRICULA FROM T_SIP_DEPENDENTE;
--Descobrindo quais são os funcionarios que possuem dependentes


-- Exemplo de consulta utilizando operadores aritméticos
-- RECUPERAR OS FUNCIONARIOS, APLICANDO 5% AUMENTO NO SALARIO
SELECT NR_MATRICULA,NM_FUNCIONARIO,VL_SALARIO,VL_SALARIO * 1.05 FROM T_SIP_FUNCIONARIO;
--Aqui mostra o num de matricula,nome do funcionario,valor do salario e valor do salario * 1.05
--ATENCAO:ESSE COMANDO NAO ALTERA A TABELA ORIGINAL,CASO EU QUEIRA FAZER ISSO,USAR O UPDATE


--APELIDANDO A COLUNA VL_SALARIO * 1.05
SELECT NR_MATRICULA,NM_FUNCIONARIO,VL_SALARIO AS "SALÁRIO MENSAL",VL_SALARIO * 1.05 AS "SALÁRIO REAJUSTADO" FROM T_SIP_FUNCIONARIO;
--aspas duplas:palavras compostas e com acentos
--aspas simples: palavras simples e sem acentos
--Posso usar aspas duplas no lugar da simples,mas NUNCA o contrário
--OUTRA FORMA DE FAZER:
SELECT NR_MATRICULA,NM_FUNCIONARIO,VL_SALARIO  SALARIO ,VL_SALARIO * 1.05 AS VALOR_REAJUSTADO FROM T_SIP_FUNCIONARIO;
--Se eu for usar apenas palavras simples,nao preciso colocar aspas
--Posso colocar aspas em um só se eu quiser,tipo o salario deixo sem aspas e o valor_reajustado coloco aspas


-- APRESENTANDO RESULTADOS DE FORMA ORDENADA
-- ORDER BY ASC (ASCENDENTE/CRESCENTE)
-- RECUPERAR TODOS OS DEPTOS EM ORDEM ALFABETICA CRESCENTE (A -> Z)
SELECT CD_DEPTO , NM_DEPTO FROM T_SIP_DEPARTAMENTO ORDER BY NM_DEPTO ASC;
--ordenando o nome dos departamentos em ordem crescente
--DESC:DECRESCENTE
--ASC:CRESCENTE
--Se eu nao colocar nada,por padrao ele ja deixa em ordem alfabética



-- PODEMOS ORDENAR POR MAIS DE UMA COLUNA
-- RECUPERAR OS FUNCIONARIOS, ORDENADOS POR DEPTO(ASC) E SALARIO(DESC)
SELECT  CD_DEPTO,NM_FUNCIONARIO,VL_SALARIO FROM T_SIP_FUNCIONARIO ORDER BY CD_DEPTO ASC,VL_SALARIO DESC;
--Coloca o codigo do departamento primeiro em ordem crescente,depois ele ordena os salarios em ordem descrecente



-- ORDER BY UTILIZANDO NÚMEROS QUE REPRESENTAM A POSIÇÃO DAS COLUNAS
-- NO COMANDO SELECT
SELECT  CD_DEPTO,NM_FUNCIONARIO,VL_SALARIO FROM T_SIP_FUNCIONARIO ORDER BY 1 ASC,3 DESC;
                                                                --ordey by 1 asc,O 1 representa o cd_depto,que foi o primeiro escrito aqui no select
                                                                --3 desc,o 3 representa o vl_salario,que foi o terceiro escrito aqui no select
                                                 
 -- ORDENANDO COLUNAS QUE POSSUEM ALIAS                                                               
SELECT CD_DEPTO, NR_MATRICULA,NM_FUNCIONARIO,VL_SALARIO AS "SALÁRIO MENSAL",VL_SALARIO * 1.05 AS "REAJUSTADO" 
FROM T_SIP_FUNCIONARIO ORDER BY CD_DEPTO,5 DESC;                                                          
SELECT CD_DEPTO, NR_MATRICULA,NM_FUNCIONARIO,VL_SALARIO AS "SALÁRIO MENSAL",VL_SALARIO * 1.05 AS "REAJUSTADO" 
FROM T_SIP_FUNCIONARIO ORDER BY CD_DEPTO,"REAJUSTADO" DESC;



--FILTRANDO POR NÚMEROS
SELECT NR_MATRICULA,NM_FUNCIONARIO,VL_SALARIO FROM T_SIP_FUNCIONARIO WHERE  VL_SALARIO >= 3050.67 
ORDER BY VL_SALARIO DESC;--USAR O PONTO COMO CASA DECIMAL
--Filtrando apenas funcionarios com um salario maior que 3k e em seguida ordenando em ordem decrescente
--O ORDER BY É SEMPRE O ÚLTIMO COMANDO PARA SER EXECUTADO;


--FILTRANDO POR DATAS
SELECT NR_MATRICULA,NM_FUNCIONARIO,DT_ADMISSAO FROM T_SIP_FUNCIONARIO WHERE  DT_ADMISSAO >= TO_DATE('01/08/2015', 'dd/mm/yyyy')
ORDER BY DT_ADMISSAO ASC;
--ordenando as datas de admissão em ordem crescente


--FILTRANDO POR TEXTO 
SELECT NR_MATRICULA,NM_FUNCIONARIO FROM T_SIP_FUNCIONARIO WHERE UPPER(NM_FUNCIONARIO) = 'GISELE DE JESUS';
--O WHERE UPPER TA PEGANDO O NOME FUNCIONARIO LA NA TABELA E CONVERTENDO PRA LETRA MAIUSCULA!!!!!!!!!!
--SEMPRE ASPAS SIMPLES
-- UPPER(VALOR) -> CONVERTE UM CONTEUDO PARA LETRAS MAIUSCULAS
-- LOWER(VALOR) -> CONVERTE UM CONTEUDO PARA LETRAS MINUSCULAS






















--AULA 14/09/2022
-- OPERADORES LOGICOS (AND, OR, NOT)
-- OPERADOR AND
-- OPERADOR LOGICO AND -> PRECISA ATENDER AS DUAS CONDIÇÕES PARA RECUPERAR OS VALORES
SELECT NR_MATRICULA,NM_FUNCIONARIO,CD_DEPTO,DT_ADMISSAO FROM T_SIP_FUNCIONARIO 
WHERE CD_DEPTO = 3 AND DT_ADMISSAO >= TO_DATE('01/08/2015','DD,MM,YYYY') ORDER BY DT_ADMISSAO;
 


-- OPERADOR OR
-- OPERADOR LOGICO OR -> PRECISA ANTENDER QUALQUER UMA DAS CONDIÇÕES PARA RECUPERAR OS VALORES  
SELECT NR_MATRICULA,NM_FUNCIONARIO,CD_DEPTO,VL_SALARIO FROM T_SIP_FUNCIONARIO 
WHERE  CD_DEPTO = 2 OR VL_SALARIO >= 3000
ORDER BY VL_SALARIO;
 


-- OPERADOR NOT (NEGAÇÃO)
SELECT NR_MATRICULA,NM_FUNCIONARIO,CD_DEPTO,VL_SALARIO FROM T_SIP_FUNCIONARIO 
 WHERE NOT CD_DEPTO = 4 ; --Será apresentado os funcionários que não trabalhem
 --no departamento 4 
 
 
 
 -- EXEMPLOS utilizando operadores ESPECIAIS
-- OPERADOR BETWEEN -- SÓ PODE SER UTILIZADO SE AMBOS OS INTERVALOS ESTIVEREM 
--FECHADOS
-- RECUPERAR OS FUNCIONARIOS QUE GANHAM ENTRE 1000 E 2500 (INCLUSIVE)
-- SALARIO >= 1000 AND SALARIO <= 2500 (BETWEEN)
-- SALARIO > 1000  AND SALARIO <= 2500 (NÃO PODE USAR BETWEEN)
-- SALARIO >= 1000 AND SALARIO < 2500  (NÃO PODE USAR BETWEEN)
-- SALARIO > 1000  AND SALARIO < 2500  (NÃO PODE USAR BETWEEN)

SELECT NR_MATRICULA,NM_FUNCIONARIO,VL_SALARIO FROM T_SIP_FUNCIONARIO 
WHERE VL_SALARIO BETWEEN 100 AND 2500;
--tem o mesmo significado que vl_salario <= 1000 and vl_salario >= 2500

SELECT NR_MATRICULA,NM_FUNCIONARIO,VL_SALARIO FROM T_SIP_FUNCIONARIO 
WHERE DT_ADMISSAO BETWEEN TO_DATE('01/08/2015','DD/MM/YYYY') AND TO_DATE('31/12/2019','DD/MM/YYYY');
-- EQUIVALE A ESCREVER:
-- DT_ADMISSAO >= TO_DATE('01/08/2015','DD/MM/YYYY') AND
-- DT_ADMISSAO <= TO_DATE('31/12/2019','DD/MM/YYYY')



-- OPERADOR IN (AVALIA LISTA DE VALORES)
SELECT NR_MATRICULA ,NM_FUNCIONARIO,CD_DEPTO 
FROM T_SIP_FUNCIONARIO WHERE CD_DEPTO IN (1,2,3);
 -- CD_DEPTO IN (1,2,3) EQUIVALE
 -- CD_DEPTO = 1 OR CD_DEPTO = 2 OR CD_DEPTO = 3

 

 
-- OPERADOR NOT IN

 SELECT NR_MATRICULA ,NM_FUNCIONARIO,CD_DEPTO 
FROM T_SIP_FUNCIONARIO WHERE CD_DEPTO NOT IN (1,2,3);
-- CD_DEPTO NOT IN (1,2,3) EQUIVALE
-- CD_DEPTO <> 1 AND CD_DEPTO <> 2 AND CD_DEPTO <> 3

 

-- OPERADOR IN

 -- CD_DEPTO IN (1,2,3) EQUIVALE
-- TO_CHAR() -> CONVERTE UM CONTEUDO PARA TEXTO
-- TO_CHAR(DT_ADMISSAO, 'YYYY') -- EXTRAIR O ANO DA DATA PARA CARACTERES
-- SE O ANO DA DATA ADMISSAO É 2012 OU 2014
-- WHERE TO_CHAR(DT_ADMISSAO, 'YYYY') IN ('2012','2014')

SELECT NR_MATRICULA ,NM_FUNCIONARIO,CD_DEPTO,DT_ADMISSAO 
FROM T_SIP_FUNCIONARIO WHERE TO_CHAR(DT_ADMISSAO , 'YYYY') IN ('2012','2014');
--da data extrai o ano e converti ela em texto
--caso eu quisesse puxar a data e o ano de uma vez: TO_CHAR(DT_ADMISSAO , 'MM/YYYY') IN ('08/2012','11/2014');
-- EQUIVALE:  
/*
   DT_ADMISSAO BETWEEN TO_DATE('01/01/2012','DD/MM/YYYY') AND
                       TO_DATE('31/12/2012','DD/MM/YYYY') OR
   DT_ADMISSAO BETWEEN TO_DATE('01/01/2014','DD/MM/YYYY') AND
                       TO_DATE('31/12/2014','DD/MM/YYYY')
*/                       
/*
   DT_ADMISSAO >=  TO_DATE('01/01/2012','DD/MM/YYYY') AND
   DT_ADMISSAO <=  TO_DATE('31/12/2012','DD/MM/YYYY') OR
   DT_ADMISSAO >=  TO_DATE('01/01/2014','DD/MM/YYYY') AND
   DT_ADMISSAO <=  TO_DATE('31/12/2014','DD/MM/YYYY')
*/ 


-- OPERADOR IS NOT NULL
-- RECUPERAR OS PROJETOS FINALIZADOS - POSSUEM DATA TERMINO
SELECT CD_PROJETO,NM_PROJETO,DT_TERMINO 
    FROM T_SIP_PROJETO 
    WHERE DT_TERMINO IS NOT NULL;
 

-- OPERADOR IS NULL
-- RECUPERAR PROJETOS EM ANDAMENTO - NÃO POSSUEM DATA TERMINO
SELECT CD_PROJETO,NM_PROJETO,DT_TERMINO 
    FROM T_SIP_PROJETO 
    WHERE DT_TERMINO IS NULL;
-- SO FAZ SENTIDO USAR IS NULL/ IS NOT NULL, PARA AVALIAR COLUNAS/CAMPOS OPCIONAIS

-- OPERADOR LIKE (RECUPERA AS CORRESPONDENCIAS: EX, TUDO QUE COMEÇA COM A LETRA "A", TODOS OS NOMES QUE
-- CONTEM "SILVA"
-- % -> EQUIVALE A UMA CADEIA DE CARACTERES
-- _ -> EQUIVALE A APENAS UM CARACTER
 

-- TODOS OS FUNCIONARIOS QUE O NOME COMEÇA COM A LETRA 'A'
SELECT NR_MATRICULA,NM_FUNCIONARIO 
FROM T_SIP_FUNCIONARIO
WHERE UPPER(NM_FUNCIONARIO) LIKE 'A%'; --o A% significa que ira ser trago o que estiver APÓS a letra A
-- TODOS OS FUNCIONARIOS QUE POSSUEM SILVA NO NOME
SELECT NR_MATRICULA,NM_FUNCIONARIO 
FROM T_SIP_FUNCIONARIO
WHERE UPPER(NM_FUNCIONARIO) LIKE '%SILVA%'; -- o %SILVA% significa que irá ser trago o que estiver ANTES e APÓS a palavra SILVA
 


-- TODOS OS DEPTOS QUE TENHA O SEGUNDO CARACTERE DO NOME A LETRA "A"
 SELECT CD_DEPTO ,NM_DEPTO
 FROM T_SIP_DEPARTAMENTO
 WHERE UPPER(NM_DEPTO) LIKE '_A%'; -- O _ representa o primeiro caracter mais inutil
 
 
-- TODOS OS DEPTOS QUE TENHA O QUARTO E QUINTO CARACTERE DO NOME AS LETRAS "UR"  
SELECT CD_DEPTO ,NM_DEPTO
 FROM T_SIP_DEPARTAMENTO
 WHERE UPPER(NM_DEPTO) LIKE '___UR%';
 
 --USAR POUCO PQ ELE DEMORA PARA TRAZER OS RESULTADOS!!!!!!
 
 
 -- OPERADOR DE CONCATENAÇÃO - BARRAS PARALELAS (||)
-- EXIBIR O TEXTO: "O FUNCIONARIO <NOME> FOI
--   ADMITIDO EM <DATA ADMISSAO>"
SELECT 'O funcionário ' || NM_FUNCIONARIO || ' foi admitido em: ' || DT_ADMISSAO 
FROM T_SIP_FUNCIONARIO
ORDER BY NM_FUNCIONARIO; 


-- UTILIZANDO A PSEUDOCOLUNA ROWNUM (NUMERO DA LINHA)
SELECT ROWNUM,CD_DEPTO,NM_DEPTO
FROM T_SIP_DEPARTAMENTO
ORDER BY NM_DEPTO;
 
-- RESTRINGINDO A QUANTIDADE DE LINHAS RECUPERADAS DURANTE A CONSULTA
-- RECUPERAR OS 5 FUNCIONARIOS COM MAIOR SALARIO
SELECT ROWNUM,NR_MATRICULA,NM_FUNCIONARIO,VL_SALARIO
FROM T_SIP_FUNCIONARIO
WHERE ROWNUM <= 5
ORDER BY VL_SALARIO DESC;

 --PRIMEIRO ACONTECE O WHERE E DEPOIS ACONTECE O ROWUNM,ENTAO SE EU ORDERNAR POR 
 --SALARIO A COLUNA ROWNUM FICARA BAGUNÇADA;
-- A ORDENAÇÃO E FEITA DEPOIS DO FILTRO COM WHERE,
-- PORTANTO DESTA FORMA, NAÕ CONSEGUIMOS RANKING
-- CORTAMOS APENAS A QTDE DE LINHAS DESEJADA PARA A CONSULTA

-- PARA EXIBIR OS NOMES E OS SALÁRIOS DOS TRÊS FUNCIONÁRIOS
-- MAIS BEM REMUNERADOS DA TABELA FUNCIONARIO.
SELECT ROWNUM AS RANK,NM_FUNCIONARIO , VL_SALARIO
FROM(
         SELECT NM_FUNCIONARIO , VL_SALARIO
         FROM T_SIP_FUNCIONARIO
         ORDER BY VL_SALARIO DESC)
 
WHERE ROWNUM <= 3;